"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([[2420],{

/***/ 22420:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  ElevationQuery: () => (/* binding */ v)\n});\n\n// UNUSED EXPORTS: GeometryDescriptor, getFinestLodIndex\n\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/asyncUtils.js\nvar asyncUtils = __webpack_require__(67979);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/Error.js\nvar core_Error = __webpack_require__(70375);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/maybe.js\nvar maybe = __webpack_require__(61681);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/promiseUtils.js\nvar promiseUtils = __webpack_require__(78668);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/unitUtils.js\nvar unitUtils = __webpack_require__(17321);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry/Multipoint.js\nvar Multipoint = __webpack_require__(74304);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry/Point.js + 1 modules\nvar Point = __webpack_require__(67666);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry/Polyline.js\nvar Polyline = __webpack_require__(90819);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry/projection.js + 1 modules\nvar projection = __webpack_require__(92376);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry/support/aaBoundingRect.js\nvar aaBoundingRect = __webpack_require__(24568);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry.js\nvar geometry = __webpack_require__(91957);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/has.js\nvar has = __webpack_require__(39994);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/core/Logger.js\nvar Logger = __webpack_require__(13802);\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/geometry/support/webMercatorUtils.js\nvar webMercatorUtils = __webpack_require__(39536);\n;// CONCATENATED MODULE: ./node_modules/@arcgis/core/layers/support/ElevationSampler.js\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nconst r=Logger/* default */.Z.getLogger(\"esri.layers.support.ElevationSampler\");class l{queryElevation(e){return u(e.clone(),this)}on(){return d}projectIfRequired(e,t){return p(e,t)}}class m extends l{get spatialReference(){return this.extent.spatialReference}constructor(e,s,i){super(),this.tile=e,this.noDataValue=i;const o=e.tile.extent;this.extent=(0,aaBoundingRect/* toExtent */.HH)(o,s.spatialReference),this.extent.zmin=e.zmin,this.extent.zmax=e.zmax,this._aaExtent=o;const a=(0,unitUtils/* getMetersPerUnitForSR */.c9)(s.spatialReference),r=s.lodAt(e.tile.level).resolution*a;this.demResolution={min:r,max:r}}contains(e){const t=this.projectIfRequired(e,this.spatialReference);return null!=t&&this.containsAt(t.x,t.y)}containsAt(e,t){return (0,aaBoundingRect/* containsXY */.jE)(this._aaExtent,e,t)}elevationAt(e,t){if(!this.containsAt(e,t)){const n=this.extent,s=`${n.xmin}, ${n.ymin}, ${n.xmax}, ${n.ymax}`;return r.warn(\"#elevationAt()\",`Point used to sample elevation (${e}, ${t}) is outside of the sampler extent (${s})`),this.noDataValue}return this.tile.sample(e,t)??this.noDataValue}}class c extends l{get spatialReference(){return this.extent.spatialReference}constructor(e,t,s){let o;super(),\"number\"==typeof t?(this.noDataValue=t,o=null):(o=t,this.noDataValue=s),this.samplers=o?e.map((e=>new m(e,o,this.noDataValue))):e;const a=this.samplers[0];if(a){this.extent=a.extent.clone();const{min:e,max:t}=a.demResolution;this.demResolution={min:e,max:t};for(let n=1;n<this.samplers.length;n++){const e=this.samplers[n];this.extent.union(e.extent),this.demResolution.min=Math.min(this.demResolution.min,e.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,e.demResolution.max)}}else this.extent=(0,aaBoundingRect/* toExtent */.HH)((0,aaBoundingRect/* create */.Ue)(),o.spatialReference),this.demResolution={min:0,max:0}}elevationAt(e,t){for(const n of this.samplers)if(n.containsAt(e,t))return n.elevationAt(e,t);return r.warn(\"#elevationAt()\",`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue}}function u(e,t){const n=p(e,t.spatialReference);if(!n)return null;switch(e.type){case\"point\":h(e,n,t);break;case\"polyline\":f(e,n,t);break;case\"multipoint\":x(e,n,t)}return e}function p(e,t){if(null==e)return null;const n=e.spatialReference;if(n.equals(t))return e;const s=(0,webMercatorUtils/* project */.iV)(e,t);return s||r.error(`Cannot project geometry spatial reference (wkid:${n.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),s}function h(e,t,n){e.z=n.elevationAt(t.x,t.y)}function f(e,t,n){R.spatialReference=t.spatialReference;const s=e.hasM&&!e.hasZ;for(let i=0;i<e.paths.length;i++){const o=e.paths[i],a=t.paths[i];for(let e=0;e<o.length;e++){const t=o[e],i=a[e];R.x=i[0],R.y=i[1],s&&(t[3]=t[2]),t[2]=n.elevationAt(R.x,R.y)}}e.hasZ=!0}function x(e,t,n){R.spatialReference=t.spatialReference;const s=e.hasM&&!e.hasZ;for(let i=0;i<e.points.length;i++){const o=e.points[i],a=t.points[i];R.x=a[0],R.y=a[1],s&&(o[3]=o[2]),o[2]=n.elevationAt(R.x,R.y)}e.hasZ=!0}const R=new Point/* default */.Z,d={remove(){}};\n\n;// CONCATENATED MODULE: ./node_modules/@arcgis/core/layers/support/ElevationSamplerData.js\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nclass ElevationSamplerData_t{constructor(t,h){this.data=t,this.safeWidth=.99999999*(t.width-1),this.dx=(t.width-1)/(h[2]-h[0]),this.dy=(t.width-1)/(h[3]-h[1]),this.x0=h[0],this.y1=h[3]}}\n\n;// CONCATENATED MODULE: ./node_modules/@arcgis/core/layers/support/ElevationTile.js\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nclass ElevationTile_t{constructor(t,l=null){if(this.tile=t,null!=l&&null!=t){const e=t.extent;this._samplerData=new ElevationSamplerData_t(l,e)}}get zmin(){return null!=this._samplerData?this._samplerData.data.minValue:0}get zmax(){return null!=this._samplerData?this._samplerData.data.maxValue:0}sample(a,t){if(null==this._samplerData)return;const{safeWidth:e,data:r,dx:s,dy:n,y1:i,x0:u}=this._samplerData,{width:m,values:o,noDataValue:h}=r,p=ElevationTile_l(n*(i-t),0,e),D=ElevationTile_l(s*(a-u),0,e),f=Math.floor(p),c=Math.floor(D),d=f*m+c,_=d+m,x=o[d],V=o[_],g=o[d+1],v=o[_+1];if(x!==h&&V!==h&&g!==h&&v!==h){const a=D-c,t=x+(g-x)*a;return t+(V+(v-V)*a-t)*(p-f)}}}function ElevationTile_l(a,t,l){return a<t?t:a>l?l:a}\n\n// EXTERNAL MODULE: ./node_modules/@arcgis/core/layers/support/TileKey.js\nvar TileKey = __webpack_require__(23758);\n;// CONCATENATED MODULE: ./node_modules/@arcgis/core/layers/support/ElevationQuery.js\n/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.27/esri/copyright.txt for details.\n*/\nclass v{async queryAll(e,i,n){if(!(e=n&&n.ignoreInvisibleLayers?e.filter((e=>e.visible)):e.slice()).length)throw new core_Error/* default */.Z(\"elevation-query:invalid-layer\",\"Elevation queries require at least one elevation layer to fetch tiles from\");const l=w.fromGeometry(i);let s=!1;n&&n.returnSampleInfo||(s=!0);const o={...q,...n,returnSampleInfo:!0},a=await this.query(e[e.length-1],l,o),r=await this._queryAllContinue(e,a,o);return r.geometry=r.geometry.export(),s&&delete r.sampleInfo,r}async query(e,i,n){if(!e)throw new core_Error/* default */.Z(\"elevation-query:invalid-layer\",\"Elevation queries require an elevation layer to fetch tiles from\");if(!i||!(i instanceof w)&&\"point\"!==i.type&&\"multipoint\"!==i.type&&\"polyline\"!==i.type)throw new core_Error/* default */.Z(\"elevation-query:invalid-geometry\",\"Only point, polyline and multipoint geometries can be used to query elevation\");const l={...q,...n},s=new _(e,i.spatialReference,l),o=l.signal;return await e.load({signal:o}),await this._createGeometryDescriptor(s,i,o),await this._selectTiles(s,o),await this._populateElevationTiles(s,o),this._sampleGeometryWithElevation(s),this._createQueryResult(s,o)}async createSampler(e,i,n){if(!e)throw new core_Error/* default */.Z(\"elevation-query:invalid-layer\",\"Elevation queries require an elevation layer to fetch tiles from\");if(!i||\"extent\"!==i.type)throw new core_Error/* default */.Z(\"elevation-query:invalid-extent\",\"Invalid or undefined extent\");const l={...q,...n};return this._createSampler(e,i,l)}async createSamplerAll(e,i,n){if(!(e=n&&n.ignoreInvisibleLayers?e.filter((e=>e.visible)):e.slice()).length)throw new core_Error/* default */.Z(\"elevation-query:invalid-layer\",\"Elevation queries require at least one elevation layer to fetch tiles from\");if(!i||\"extent\"!==i.type)throw new core_Error/* default */.Z(\"elevation-query:invalid-extent\",\"Invalid or undefined extent\");const l={...q,...n,returnSampleInfo:!0},s=await this._createSampler(e[e.length-1],i,l);return this._createSamplerAllContinue(e,i,s,l)}async _createSampler(e,t,i,n){const l=i.signal;await e.load({signal:l});const s=t.spatialReference,o=e.tileInfo.spatialReference;s.equals(o)||(await (0,projection.initializeProjection)([{source:s,dest:o}],{signal:l}),t=(0,projection/* project */.iV)(t,o));const a=new E(e,t,i,n);return await this._selectTiles(a,l),await this._populateElevationTiles(a,l),new c(a.elevationTiles,a.layer.tileInfo,a.options.noDataValue)}async _createSamplerAllContinue(e,t,i,n){if(e.pop(),!e.length)return i;const l=i.samplers.map((e=>(0,aaBoundingRect/* fromExtent */.oJ)(e.extent))),s=await this._createSampler(e[e.length-1],t,n,l);if(0===s.samplers.length)return i;const o=i.samplers.concat(s.samplers),a=new c(o,n.noDataValue);return this._createSamplerAllContinue(e,t,a,n)}async _queryAllContinue(e,t,n){const l=e.pop(),s=t.geometry.coordinates,o=t.sampleInfo;(0,maybe/* assertIsSome */.O3)(o);const a=[],r=[];for(let i=0;i<s.length;i++){const t=o[i];t.demResolution>=0?t.source||(t.source=l):e.length&&(a.push(s[i]),r.push(i))}if(!e.length||0===a.length)return t;const c=t.geometry.clone(a),u=await this.query(e[e.length-1],c,n),h=u.sampleInfo;if(!h)throw new Error(\"no sampleInfo\");return r.forEach(((e,t)=>{s[e].z=u.geometry.coordinates[t].z,o[e].demResolution=h[t].demResolution})),this._queryAllContinue(e,t,n)}async _createQueryResult(e,t){const n=await e.geometry.project(e.outSpatialReference,t);(0,maybe/* assertIsSome */.O3)(n);const l={geometry:n.export(),noDataValue:e.options.noDataValue};return e.options.returnSampleInfo&&(l.sampleInfo=this._extractSampleInfo(e)),e.geometry.coordinates.forEach((e=>{e.tile=null,e.elevationTile=null})),l}async _createGeometryDescriptor(e,i,n){let l;const s=e.layer.tileInfo.spatialReference;if(i instanceof w?l=await i.project(s,n):(await (0,projection.initializeProjection)([{source:i.spatialReference,dest:s}],{signal:n}),l=(0,projection/* project */.iV)(i,s)),!l)throw new core_Error/* default */.Z(\"elevation-query:spatial-reference-mismatch\",`Cannot query elevation in '${i.spatialReference.wkid}' on an elevation service in '${s.wkid}'`);e.geometry=w.fromGeometry(l)}async _selectTiles(e,i){\"geometry\"===e.type&&this._preselectOutsideLayerExtent(e);const n=e.options.demResolution;if(\"number\"==typeof n)this._selectTilesClosestResolution(e,n);else if(\"finest-contiguous\"===n)await this._selectTilesFinestContiguous(e,i);else{if(\"auto\"!==n)throw new core_Error/* default */.Z(\"elevation-query:invalid-dem-resolution\",`Invalid dem resolution value '${n}', expected a number, \"finest-contiguous\" or \"auto\"`);await this._selectTilesAuto(e,i)}}_preselectOutsideLayerExtent(e){if(null==e.layer.fullExtent)return;const t=new ElevationTile_t(null);t.sample=()=>e.options.noDataValue,e.outsideExtentTile=t;const i=e.layer.fullExtent;e.geometry.coordinates.forEach((e=>{const n=e.x,l=e.y;(n<i.xmin||n>i.xmax||l<i.ymin||l>i.ymax)&&(e.elevationTile=t)}))}_selectTilesClosestResolution(e,t){const i=this._findNearestDemResolutionLODIndex(e,t);e.selectTilesAtLOD(i)}_findNearestDemResolutionLODIndex(e,t){const{tileInfo:i,tilemapCache:n}=e.layer,l=t/(0,unitUtils/* getMetersPerUnitForSR */.c9)(i.spatialReference),s=I(i,n);let a=s[0],r=0;for(let o=1;o<s.length;o++){const e=s[o];Math.abs(e.resolution-l)<Math.abs(a.resolution-l)&&(a=e,r=o)}return r}async _selectTilesFinestContiguous(e,t){const{tileInfo:i,tilemapCache:n}=e.layer,l=ElevationQuery_R(i,n,e.options.minDemResolution);await this._selectTilesFinestContiguousAt(e,l,t)}async _selectTilesFinestContiguousAt(e,i,s){const o=e.layer;if(e.selectTilesAtLOD(i),i<0)return;const a=o.tilemapCache,r=e.getTilesToFetch();try{if(a&&!A(a))await (0,promiseUtils/* whenOrAbort */.Hl)(Promise.all(r.map((e=>a.fetchAvailability(e.level,e.row,e.col,{signal:s})))),s);else if(await this._populateElevationTiles(e,s),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new core_Error/* default */.Z(\"elevation-query:has-unavailable-tiles\")}catch(c){(0,promiseUtils/* throwIfAbortError */.r9)(c),await this._selectTilesFinestContiguousAt(e,i-1,s)}}async _populateElevationTiles(e,t){const i=e.getTilesToFetch(),l={},o=e.options.cache,a=e.options.noDataValue,r=i.map((async i=>{if(null==i.id)return;const n=`${e.layer.uid}:${i.id}:${a}`,s=null!=o?o.get(n):null,r=null!=s?s:await e.layer.fetchTile(i.level,i.row,i.col,{noDataValue:a,signal:t});null!=o&&o.put(n,r),l[i.id]=new ElevationTile_t(i,r)}));await (0,promiseUtils/* whenOrAbort */.Hl)((0,promiseUtils/* eachAlways */.as)(r),t),e.populateElevationTiles(l)}async _selectTilesAuto(t,i){this._selectTilesAutoFinest(t),this._reduceTilesForMaximumRequests(t);const s=t.layer.tilemapCache;if(!s||A(s))return this._selectTilesAutoPrefetchUpsample(t,i);const o=t.getTilesToFetch(),a={},r=o.map((async t=>{const n=new TileKey/* TileKey */.f(null,0,0,0,(0,aaBoundingRect/* create */.Ue)()),o=await (0,asyncUtils/* result */.q6)(s.fetchAvailabilityUpsample(t.level,t.row,t.col,n,{signal:i}));!1!==o.ok?null!=t.id&&(a[t.id]=n):(0,promiseUtils/* throwIfAbortError */.r9)(o.error)}));await (0,promiseUtils/* whenOrAbort */.Hl)(Promise.all(r),i),t.remapTiles(a)}_reduceTilesForMaximumRequests(e){const t=e.layer.tileInfo;let i=0;const n={},l=e=>{null!=e.id&&(e.id in n?n[e.id]++:(n[e.id]=1,i++))},s=e=>{if(null==e.id)return;const t=n[e.id];1===t?(delete n[e.id],i--):n[e.id]=t-1};e.forEachTileToFetch(l,s);let o=!0;for(;o&&(o=!1,e.forEachTileToFetch((n=>{i<=e.options.maximumAutoTileRequests||(s(n),t.upsampleTile(n)&&(o=!0),l(n))}),s),o););}_selectTilesAutoFinest(e){const{tileInfo:t,tilemapCache:i}=e.layer,n=ElevationQuery_R(t,i,e.options.minDemResolution);e.selectTilesAtLOD(n,e.options.maximumAutoTileRequests)}async _selectTilesAutoPrefetchUpsample(e,t){const i=e.layer.tileInfo;await this._populateElevationTiles(e,t);let n=!1;e.forEachTileToFetch(((e,t)=>{i.upsampleTile(e)?n=!0:t()})),n&&await this._selectTilesAutoPrefetchUpsample(e,t)}_sampleGeometryWithElevation(e){e.geometry.coordinates.forEach((t=>{const i=t.elevationTile;let n=e.options.noDataValue;if(i){const e=i.sample(t.x,t.y);null!=e?n=e:t.elevationTile=null}t.z=n}))}_extractSampleInfo(e){const t=e.layer.tileInfo,i=(0,unitUtils/* getMetersPerUnitForSR */.c9)(t.spatialReference);return e.geometry.coordinates.map((n=>{let l=-1;if(n.elevationTile&&n.elevationTile!==e.outsideExtentTile){l=t.lodAt(n.elevationTile.tile.level).resolution*i}return{demResolution:l}}))}}class w{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(e){const t=new w;return t.geometry=this.geometry,t.spatialReference=this.spatialReference,t.coordinates=e||this.coordinates.map((e=>e.clone())),t._exporter=this._exporter,t}async project(e,t){if(this.spatialReference.equals(e))return this.clone();await (0,projection.initializeProjection)([{source:this.spatialReference,dest:e}],{signal:t});const i=new Multipoint/* default */.Z({spatialReference:this.spatialReference,points:this.coordinates.map((e=>[e.x,e.y]))}),n=(0,projection/* project */.iV)(i,e);if(!n)return null;const l=this.coordinates.map(((e,t)=>{const i=e.clone(),l=n.points[t];return i.x=l[0],i.y=l[1],i})),s=this.clone(l);return s.spatialReference=e,s}static fromGeometry(e){const t=new w;if(t.geometry=e,t.spatialReference=e.spatialReference,e instanceof w)t.coordinates=e.coordinates.map((e=>e.clone())),t._exporter=(t,i)=>{const n=e.clone(t);return n.spatialReference=i,n};else switch(e.type){case\"point\":{const i=e,{hasZ:n,hasM:l}=i;t.coordinates=n&&l?[new g(i.x,i.y,i.z,i.m)]:n?[new g(i.x,i.y,i.z)]:l?[new g(i.x,i.y,null,i.m)]:[new g(i.x,i.y)],t._exporter=(t,i)=>e.hasM?new Point/* default */.Z(t[0].x,t[0].y,t[0].z,t[0].m,i):new Point/* default */.Z(t[0].x,t[0].y,t[0].z,i);break}case\"multipoint\":{const i=e,{hasZ:n,hasM:l}=i;t.coordinates=n&&l?i.points.map((e=>new g(e[0],e[1],e[2],e[3]))):n?i.points.map((e=>new g(e[0],e[1],e[2]))):l?i.points.map((e=>new g(e[0],e[1],null,e[2]))):i.points.map((e=>new g(e[0],e[1]))),t._exporter=(t,i)=>e.hasM?new Multipoint/* default */.Z({points:t.map((e=>[e.x,e.y,e.z,e.m])),hasZ:!0,hasM:!0,spatiaReference:i}):new Multipoint/* default */.Z(t.map((e=>[e.x,e.y,e.z])),i);break}case\"polyline\":{const i=e,n=[],l=[],{hasZ:s,hasM:o}=e;let a=0;for(const e of i.paths)if(l.push([a,a+e.length]),a+=e.length,s&&o)for(const t of e)n.push(new g(t[0],t[1],t[2],t[3]));else if(s)for(const t of e)n.push(new g(t[0],t[1],t[2]));else if(o)for(const t of e)n.push(new g(t[0],t[1],null,t[2]));else for(const t of e)n.push(new g(t[0],t[1]));t.coordinates=n,t._exporter=(t,i)=>{const n=e.hasM?t.map((e=>[e.x,e.y,e.z,e.m])):t.map((e=>[e.x,e.y,e.z])),s=l.map((e=>n.slice(e[0],e[1])));return new Polyline/* default */.Z({paths:s,hasM:e.hasM,hasZ:!0,spatialReference:i})};break}}return t}}class g{constructor(e,t,i=null,n=null,l=null,s=null){this.x=e,this.y=t,this.z=i,this.m=n,this.tile=l,this.elevationTile=s}clone(){return new g(this.x,this.y,this.z,this.m)}}class ElevationQuery_x{constructor(e,t){this.layer=e,this.options=t}}class _ extends ElevationQuery_x{constructor(e,t,i){super(e,i),this.outSpatialReference=t,this.type=\"geometry\"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach((e=>e.tile=null));else{const{tileInfo:t,tilemapCache:i}=this.layer,n=I(t,i)[e].level;this.geometry.coordinates.forEach((e=>e.tile=t.tileAt(n,e.x,e.y)))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((e=>!e.elevationTile))}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){for(const t of this.geometry.coordinates)!t.elevationTile&&t.tile?.id&&(t.elevationTile=e[t.tile.id])}remapTiles(e){for(const t of this.geometry.coordinates){const i=t.tile?.id;t.tile=i?e[i]:null}}getTilesToFetch(){const e={},t=[];for(const i of this.geometry.coordinates){const n=i.tile;if(!n)continue;const l=i.tile?.id;i.elevationTile||!l||e[l]||(e[l]=n,t.push(n))}return t}forEachTileToFetch(e){for(const t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,(()=>{t.tile=null}))}}class E extends ElevationQuery_x{constructor(e,t,i,n){super(e,i),this.type=\"extent\",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=t.intersection(e.fullExtent),this.maskExtents=n}selectTilesAtLOD(e,t){const i=this._maximumLodForRequests(t),n=Math.min(i,e);n<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(n)}_maximumLodForRequests(e){const{tileInfo:t,tilemapCache:i}=this.layer,n=I(t,i);if(!e)return n.length-1;const l=this.extent;if(null==l)return-1;for(let s=n.length-1;s>=0;s--){const i=n[s],o=i.resolution*t.size[0],a=i.resolution*t.size[1];if(Math.ceil(l.width/o)*Math.ceil(l.height/a)<=e)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(e){for(const t of this._candidateTiles){const i=t.id&&e[t.id];i&&(this._fetchedCandidates.add(t),this.elevationTiles.push(i))}}remapTiles(e){this._candidateTiles=this._uniqueNonOverlappingTiles(this._candidateTiles.map((t=>e[t.id])))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(e,t){const i=this._candidateTiles;this._candidateTiles=[],i.forEach((i=>{if(this._fetchedCandidates.has(i))return void(t&&t(i));let n=!1;e(i,(()=>n=!0)),n?t&&t(i):this._candidateTiles.push(i)})),this._candidateTiles=this._uniqueNonOverlappingTiles(this._candidateTiles,t)}_uniqueNonOverlappingTiles(e,t){const i={},n=[];for(const s of e){const e=s.id;e&&!i[e]?(i[e]=s,n.push(s)):t&&t(s)}const l=n.sort(((e,t)=>e.level-t.level));return l.filter(((e,i)=>{for(let n=0;n<i;n++){const i=l[n].extent;if(i&&e.extent&&(0,aaBoundingRect/* contains */.r3)(i,e.extent))return t&&t(e),!1}return!0}))}_selectCandidateTilesCoveringExtentAt(e){this._candidateTiles.length=0;const t=this.extent;if(null==t)return;const{tileInfo:i,tilemapCache:n}=this.layer,l=I(i,n)[e],s=i.tileAt(l.level,t.xmin,t.ymin),o=s.extent;if(null==o)return;const a=l.resolution*i.size[0],r=l.resolution*i.size[1],c=Math.ceil((t.xmax-o[0])/a),u=Math.ceil((t.ymax-o[1])/r);for(let h=0;h<u;h++)for(let e=0;e<c;e++){const t=new TileKey/* TileKey */.f(null,s.level,s.row-h,s.col+e);i.updateTileInfo(t),this._tileIsMasked(t)||this._candidateTiles.push(t)}}_tileIsMasked(e){return!!this.maskExtents&&this.maskExtents.some((t=>e.extent&&(0,aaBoundingRect/* contains */.r3)(t,e.extent)))}}function ElevationQuery_R(e,t,i=0){const n=I(e,t);let l=n.length-1;if(i>0){const t=i/(0,unitUtils/* getMetersPerUnitForSR */.c9)(e.spatialReference),s=n.findIndex((e=>e.resolution<t));0===s?l=0:s>0&&(l=s-1)}return l}const q={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:\"auto\",minDemResolution:0};function I(e,t){const i=e.lods;if(A(t)){const{effectiveMinLOD:e,effectiveMaxLOD:n}=t;return i.filter((t=>t.level>=e&&t.level<=n))}return i}function A(e){return null!=e?.tileInfo}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVLE1BQU0sMENBQTBDLGVBQWUsZUFBZSxtQkFBbUIsOENBQThDLFNBQVMsc0JBQXNCLGtGQUFrRixZQUFZLElBQUksZ0JBQWdCLGdCQUFDLENBQUMscUJBQXFCLHlLQUF5SyxzQkFBc0IsdURBQXVELGdGQUFnRiwwQkFBMEIsTUFBTSwwQkFBMEIscUJBQXFCLHdCQUF3QixvQkFBb0Isb0JBQW9CLHFCQUFxQixLQUFLLEtBQUssK0RBQStELDBEQUEwRCxTQUFTLDJCQUEyQixnRUFBZ0Usc0JBQXNCLDZEQUE2RCwwQkFBMEIscUNBQXFDLHNCQUFzQixpRUFBaUUsY0FBYyw2RkFBNkYsa0JBQWtCLDRCQUE0Qix3QkFBd0IsNkJBQTZCLHVDQUF1Qyx1REFBdUQsU0FBUyx1REFBdUQsZ0ZBQWdGLGdDQUFnQyxVQUFVLE1BQU0sa0JBQWtCLGFBQWEsb0NBQW9DLHlDQUF5Qyx5QkFBeUIsWUFBWSxJQUFJLEtBQUssb0JBQW9CLGdCQUFnQixtQ0FBQywrQkFBK0IsU0FBUyxHQUFHLHlDQUF5Qyw4QkFBOEIsb0JBQW9CLGtCQUFrQixNQUFNLDBCQUEwQixxRUFBcUUsa0JBQWtCLGtIQUFrSCxZQUFZLElBQUksZ0JBQWdCLElBQUksS0FBSyxZQUFZLHNCQUFDLCtCQUErQix5RUFBeUUsaUJBQWlCLDhEQUE4RCxtQ0FBQyxnQkFBZ0IsU0FBUyxnQkFBQyxVQUFVLGVBQWUsaUJBQWlCLFFBQVEsVUFBVSwyQ0FBQyx3REFBd0QsdUJBQXVCLFNBQVMsU0FBUyxzR0FBc0csZ0JBQWdCLGVBQWUsU0FBUyxNQUFNLG9DQUFvQyxHQUFHLDZDQUE2QyxTQUFTLGNBQWMseUJBQW9HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9sYXllcnMvc3VwcG9ydC9FbGV2YXRpb25TYW1wbGVyLmpzPzQ4YzkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmNnaXMvY29yZS9sYXllcnMvc3VwcG9ydC9FbGV2YXRpb25TYW1wbGVyRGF0YS5qcz8wNmE2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvbGF5ZXJzL3N1cHBvcnQvRWxldmF0aW9uVGlsZS5qcz9iMWM4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXJjZ2lzL2NvcmUvbGF5ZXJzL3N1cHBvcnQvRWxldmF0aW9uUXVlcnkuanM/ZmZjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0XCIuLi8uLi9nZW9tZXRyeS5qc1wiO2ltcG9ydFwiLi4vLi4vY29yZS9oYXMuanNcIjtpbXBvcnQgZSBmcm9tXCIuLi8uLi9jb3JlL0xvZ2dlci5qc1wiO2ltcG9ydHtnZXRNZXRlcnNQZXJVbml0Rm9yU1IgYXMgdH1mcm9tXCIuLi8uLi9jb3JlL3VuaXRVdGlscy5qc1wiO2ltcG9ydHt0b0V4dGVudCBhcyBuLGNvbnRhaW5zWFkgYXMgcyxjcmVhdGUgYXMgaX1mcm9tXCIuLi8uLi9nZW9tZXRyeS9zdXBwb3J0L2FhQm91bmRpbmdSZWN0LmpzXCI7aW1wb3J0e3Byb2plY3QgYXMgb31mcm9tXCIuLi8uLi9nZW9tZXRyeS9zdXBwb3J0L3dlYk1lcmNhdG9yVXRpbHMuanNcIjtpbXBvcnQgYSBmcm9tXCIuLi8uLi9nZW9tZXRyeS9Qb2ludC5qc1wiO2NvbnN0IHI9ZS5nZXRMb2dnZXIoXCJlc3JpLmxheWVycy5zdXBwb3J0LkVsZXZhdGlvblNhbXBsZXJcIik7Y2xhc3MgbHtxdWVyeUVsZXZhdGlvbihlKXtyZXR1cm4gdShlLmNsb25lKCksdGhpcyl9b24oKXtyZXR1cm4gZH1wcm9qZWN0SWZSZXF1aXJlZChlLHQpe3JldHVybiBwKGUsdCl9fWNsYXNzIG0gZXh0ZW5kcyBse2dldCBzcGF0aWFsUmVmZXJlbmNlKCl7cmV0dXJuIHRoaXMuZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2V9Y29uc3RydWN0b3IoZSxzLGkpe3N1cGVyKCksdGhpcy50aWxlPWUsdGhpcy5ub0RhdGFWYWx1ZT1pO2NvbnN0IG89ZS50aWxlLmV4dGVudDt0aGlzLmV4dGVudD1uKG8scy5zcGF0aWFsUmVmZXJlbmNlKSx0aGlzLmV4dGVudC56bWluPWUuem1pbix0aGlzLmV4dGVudC56bWF4PWUuem1heCx0aGlzLl9hYUV4dGVudD1vO2NvbnN0IGE9dChzLnNwYXRpYWxSZWZlcmVuY2UpLHI9cy5sb2RBdChlLnRpbGUubGV2ZWwpLnJlc29sdXRpb24qYTt0aGlzLmRlbVJlc29sdXRpb249e21pbjpyLG1heDpyfX1jb250YWlucyhlKXtjb25zdCB0PXRoaXMucHJvamVjdElmUmVxdWlyZWQoZSx0aGlzLnNwYXRpYWxSZWZlcmVuY2UpO3JldHVybiBudWxsIT10JiZ0aGlzLmNvbnRhaW5zQXQodC54LHQueSl9Y29udGFpbnNBdChlLHQpe3JldHVybiBzKHRoaXMuX2FhRXh0ZW50LGUsdCl9ZWxldmF0aW9uQXQoZSx0KXtpZighdGhpcy5jb250YWluc0F0KGUsdCkpe2NvbnN0IG49dGhpcy5leHRlbnQscz1gJHtuLnhtaW59LCAke24ueW1pbn0sICR7bi54bWF4fSwgJHtuLnltYXh9YDtyZXR1cm4gci53YXJuKFwiI2VsZXZhdGlvbkF0KClcIixgUG9pbnQgdXNlZCB0byBzYW1wbGUgZWxldmF0aW9uICgke2V9LCAke3R9KSBpcyBvdXRzaWRlIG9mIHRoZSBzYW1wbGVyIGV4dGVudCAoJHtzfSlgKSx0aGlzLm5vRGF0YVZhbHVlfXJldHVybiB0aGlzLnRpbGUuc2FtcGxlKGUsdCk/P3RoaXMubm9EYXRhVmFsdWV9fWNsYXNzIGMgZXh0ZW5kcyBse2dldCBzcGF0aWFsUmVmZXJlbmNlKCl7cmV0dXJuIHRoaXMuZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2V9Y29uc3RydWN0b3IoZSx0LHMpe2xldCBvO3N1cGVyKCksXCJudW1iZXJcIj09dHlwZW9mIHQ/KHRoaXMubm9EYXRhVmFsdWU9dCxvPW51bGwpOihvPXQsdGhpcy5ub0RhdGFWYWx1ZT1zKSx0aGlzLnNhbXBsZXJzPW8/ZS5tYXAoKGU9Pm5ldyBtKGUsbyx0aGlzLm5vRGF0YVZhbHVlKSkpOmU7Y29uc3QgYT10aGlzLnNhbXBsZXJzWzBdO2lmKGEpe3RoaXMuZXh0ZW50PWEuZXh0ZW50LmNsb25lKCk7Y29uc3R7bWluOmUsbWF4OnR9PWEuZGVtUmVzb2x1dGlvbjt0aGlzLmRlbVJlc29sdXRpb249e21pbjplLG1heDp0fTtmb3IobGV0IG49MTtuPHRoaXMuc2FtcGxlcnMubGVuZ3RoO24rKyl7Y29uc3QgZT10aGlzLnNhbXBsZXJzW25dO3RoaXMuZXh0ZW50LnVuaW9uKGUuZXh0ZW50KSx0aGlzLmRlbVJlc29sdXRpb24ubWluPU1hdGgubWluKHRoaXMuZGVtUmVzb2x1dGlvbi5taW4sZS5kZW1SZXNvbHV0aW9uLm1pbiksdGhpcy5kZW1SZXNvbHV0aW9uLm1heD1NYXRoLm1heCh0aGlzLmRlbVJlc29sdXRpb24ubWF4LGUuZGVtUmVzb2x1dGlvbi5tYXgpfX1lbHNlIHRoaXMuZXh0ZW50PW4oaSgpLG8uc3BhdGlhbFJlZmVyZW5jZSksdGhpcy5kZW1SZXNvbHV0aW9uPXttaW46MCxtYXg6MH19ZWxldmF0aW9uQXQoZSx0KXtmb3IoY29uc3QgbiBvZiB0aGlzLnNhbXBsZXJzKWlmKG4uY29udGFpbnNBdChlLHQpKXJldHVybiBuLmVsZXZhdGlvbkF0KGUsdCk7cmV0dXJuIHIud2FybihcIiNlbGV2YXRpb25BdCgpXCIsYFBvaW50IHVzZWQgdG8gc2FtcGxlIGVsZXZhdGlvbiAoJHtlfSwgJHt0fSkgaXMgb3V0c2lkZSBvZiB0aGUgc2FtcGxlcmApLHRoaXMubm9EYXRhVmFsdWV9fWZ1bmN0aW9uIHUoZSx0KXtjb25zdCBuPXAoZSx0LnNwYXRpYWxSZWZlcmVuY2UpO2lmKCFuKXJldHVybiBudWxsO3N3aXRjaChlLnR5cGUpe2Nhc2VcInBvaW50XCI6aChlLG4sdCk7YnJlYWs7Y2FzZVwicG9seWxpbmVcIjpmKGUsbix0KTticmVhaztjYXNlXCJtdWx0aXBvaW50XCI6eChlLG4sdCl9cmV0dXJuIGV9ZnVuY3Rpb24gcChlLHQpe2lmKG51bGw9PWUpcmV0dXJuIG51bGw7Y29uc3Qgbj1lLnNwYXRpYWxSZWZlcmVuY2U7aWYobi5lcXVhbHModCkpcmV0dXJuIGU7Y29uc3Qgcz1vKGUsdCk7cmV0dXJuIHN8fHIuZXJyb3IoYENhbm5vdCBwcm9qZWN0IGdlb21ldHJ5IHNwYXRpYWwgcmVmZXJlbmNlICh3a2lkOiR7bi53a2lkfSkgdG8gZWxldmF0aW9uIHNhbXBsZXIgc3BhdGlhbCByZWZlcmVuY2UgKHdraWQ6JHt0LndraWR9KWApLHN9ZnVuY3Rpb24gaChlLHQsbil7ZS56PW4uZWxldmF0aW9uQXQodC54LHQueSl9ZnVuY3Rpb24gZihlLHQsbil7Ui5zcGF0aWFsUmVmZXJlbmNlPXQuc3BhdGlhbFJlZmVyZW5jZTtjb25zdCBzPWUuaGFzTSYmIWUuaGFzWjtmb3IobGV0IGk9MDtpPGUucGF0aHMubGVuZ3RoO2krKyl7Y29uc3Qgbz1lLnBhdGhzW2ldLGE9dC5wYXRoc1tpXTtmb3IobGV0IGU9MDtlPG8ubGVuZ3RoO2UrKyl7Y29uc3QgdD1vW2VdLGk9YVtlXTtSLng9aVswXSxSLnk9aVsxXSxzJiYodFszXT10WzJdKSx0WzJdPW4uZWxldmF0aW9uQXQoUi54LFIueSl9fWUuaGFzWj0hMH1mdW5jdGlvbiB4KGUsdCxuKXtSLnNwYXRpYWxSZWZlcmVuY2U9dC5zcGF0aWFsUmVmZXJlbmNlO2NvbnN0IHM9ZS5oYXNNJiYhZS5oYXNaO2ZvcihsZXQgaT0wO2k8ZS5wb2ludHMubGVuZ3RoO2krKyl7Y29uc3Qgbz1lLnBvaW50c1tpXSxhPXQucG9pbnRzW2ldO1IueD1hWzBdLFIueT1hWzFdLHMmJihvWzNdPW9bMl0pLG9bMl09bi5lbGV2YXRpb25BdChSLngsUi55KX1lLmhhc1o9ITB9Y29uc3QgUj1uZXcgYSxkPXtyZW1vdmUoKXt9fTtleHBvcnR7bCBhcyBFbGV2YXRpb25TYW1wbGVyQmFzZSxjIGFzIE11bHRpVGlsZUVsZXZhdGlvblNhbXBsZXIsbSBhcyBUaWxlRWxldmF0aW9uU2FtcGxlcix1IGFzIHVwZGF0ZUdlb21ldHJ5RWxldmF0aW9ufTtcbiIsIi8qXG5BbGwgbWF0ZXJpYWwgY29weXJpZ2h0IEVTUkksIEFsbCBSaWdodHMgUmVzZXJ2ZWQsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxuU2VlIGh0dHBzOi8vanMuYXJjZ2lzLmNvbS80LjI3L2VzcmkvY29weXJpZ2h0LnR4dCBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyB0e2NvbnN0cnVjdG9yKHQsaCl7dGhpcy5kYXRhPXQsdGhpcy5zYWZlV2lkdGg9Ljk5OTk5OTk5Kih0LndpZHRoLTEpLHRoaXMuZHg9KHQud2lkdGgtMSkvKGhbMl0taFswXSksdGhpcy5keT0odC53aWR0aC0xKS8oaFszXS1oWzFdKSx0aGlzLngwPWhbMF0sdGhpcy55MT1oWzNdfX1leHBvcnR7dCBhcyBFbGV2YXRpb25TYW1wbGVyRGF0YX07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e0VsZXZhdGlvblNhbXBsZXJEYXRhIGFzIGF9ZnJvbVwiLi9FbGV2YXRpb25TYW1wbGVyRGF0YS5qc1wiO2NsYXNzIHR7Y29uc3RydWN0b3IodCxsPW51bGwpe2lmKHRoaXMudGlsZT10LG51bGwhPWwmJm51bGwhPXQpe2NvbnN0IGU9dC5leHRlbnQ7dGhpcy5fc2FtcGxlckRhdGE9bmV3IGEobCxlKX19Z2V0IHptaW4oKXtyZXR1cm4gbnVsbCE9dGhpcy5fc2FtcGxlckRhdGE/dGhpcy5fc2FtcGxlckRhdGEuZGF0YS5taW5WYWx1ZTowfWdldCB6bWF4KCl7cmV0dXJuIG51bGwhPXRoaXMuX3NhbXBsZXJEYXRhP3RoaXMuX3NhbXBsZXJEYXRhLmRhdGEubWF4VmFsdWU6MH1zYW1wbGUoYSx0KXtpZihudWxsPT10aGlzLl9zYW1wbGVyRGF0YSlyZXR1cm47Y29uc3R7c2FmZVdpZHRoOmUsZGF0YTpyLGR4OnMsZHk6bix5MTppLHgwOnV9PXRoaXMuX3NhbXBsZXJEYXRhLHt3aWR0aDptLHZhbHVlczpvLG5vRGF0YVZhbHVlOmh9PXIscD1sKG4qKGktdCksMCxlKSxEPWwocyooYS11KSwwLGUpLGY9TWF0aC5mbG9vcihwKSxjPU1hdGguZmxvb3IoRCksZD1mKm0rYyxfPWQrbSx4PW9bZF0sVj1vW19dLGc9b1tkKzFdLHY9b1tfKzFdO2lmKHghPT1oJiZWIT09aCYmZyE9PWgmJnYhPT1oKXtjb25zdCBhPUQtYyx0PXgrKGcteCkqYTtyZXR1cm4gdCsoVisodi1WKSphLXQpKihwLWYpfX19ZnVuY3Rpb24gbChhLHQsbCl7cmV0dXJuIGE8dD90OmE+bD9sOmF9ZXhwb3J0e3QgYXMgRWxldmF0aW9uVGlsZX07XG4iLCIvKlxuQWxsIG1hdGVyaWFsIGNvcHlyaWdodCBFU1JJLCBBbGwgUmlnaHRzIFJlc2VydmVkLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZC5cblNlZSBodHRwczovL2pzLmFyY2dpcy5jb20vNC4yNy9lc3JpL2NvcHlyaWdodC50eHQgZm9yIGRldGFpbHMuXG4qL1xuaW1wb3J0e3Jlc3VsdCBhcyBlfWZyb21cIi4uLy4uL2NvcmUvYXN5bmNVdGlscy5qc1wiO2ltcG9ydCB0IGZyb21cIi4uLy4uL2NvcmUvRXJyb3IuanNcIjtpbXBvcnR7YXNzZXJ0SXNTb21lIGFzIGl9ZnJvbVwiLi4vLi4vY29yZS9tYXliZS5qc1wiO2ltcG9ydHt3aGVuT3JBYm9ydCBhcyBuLHRocm93SWZBYm9ydEVycm9yIGFzIGwsZWFjaEFsd2F5cyBhcyBzfWZyb21cIi4uLy4uL2NvcmUvcHJvbWlzZVV0aWxzLmpzXCI7aW1wb3J0e2dldE1ldGVyc1BlclVuaXRGb3JTUiBhcyBvfWZyb21cIi4uLy4uL2NvcmUvdW5pdFV0aWxzLmpzXCI7aW1wb3J0IGEgZnJvbVwiLi4vLi4vZ2VvbWV0cnkvTXVsdGlwb2ludC5qc1wiO2ltcG9ydCByIGZyb21cIi4uLy4uL2dlb21ldHJ5L1BvaW50LmpzXCI7aW1wb3J0IGMgZnJvbVwiLi4vLi4vZ2VvbWV0cnkvUG9seWxpbmUuanNcIjtpbXBvcnR7aW5pdGlhbGl6ZVByb2plY3Rpb24gYXMgdSxwcm9qZWN0IGFzIGh9ZnJvbVwiLi4vLi4vZ2VvbWV0cnkvcHJvamVjdGlvbi5qc1wiO2ltcG9ydHtmcm9tRXh0ZW50IGFzIHAsY3JlYXRlIGFzIG0sY29udGFpbnMgYXMgZn1mcm9tXCIuLi8uLi9nZW9tZXRyeS9zdXBwb3J0L2FhQm91bmRpbmdSZWN0LmpzXCI7aW1wb3J0e011bHRpVGlsZUVsZXZhdGlvblNhbXBsZXIgYXMgZH1mcm9tXCIuL0VsZXZhdGlvblNhbXBsZXIuanNcIjtpbXBvcnR7RWxldmF0aW9uVGlsZSBhcyB5fWZyb21cIi4vRWxldmF0aW9uVGlsZS5qc1wiO2ltcG9ydHtUaWxlS2V5IGFzIFR9ZnJvbVwiLi9UaWxlS2V5LmpzXCI7Y2xhc3Mgdnthc3luYyBxdWVyeUFsbChlLGksbil7aWYoIShlPW4mJm4uaWdub3JlSW52aXNpYmxlTGF5ZXJzP2UuZmlsdGVyKChlPT5lLnZpc2libGUpKTplLnNsaWNlKCkpLmxlbmd0aCl0aHJvdyBuZXcgdChcImVsZXZhdGlvbi1xdWVyeTppbnZhbGlkLWxheWVyXCIsXCJFbGV2YXRpb24gcXVlcmllcyByZXF1aXJlIGF0IGxlYXN0IG9uZSBlbGV2YXRpb24gbGF5ZXIgdG8gZmV0Y2ggdGlsZXMgZnJvbVwiKTtjb25zdCBsPXcuZnJvbUdlb21ldHJ5KGkpO2xldCBzPSExO24mJm4ucmV0dXJuU2FtcGxlSW5mb3x8KHM9ITApO2NvbnN0IG89ey4uLnEsLi4ubixyZXR1cm5TYW1wbGVJbmZvOiEwfSxhPWF3YWl0IHRoaXMucXVlcnkoZVtlLmxlbmd0aC0xXSxsLG8pLHI9YXdhaXQgdGhpcy5fcXVlcnlBbGxDb250aW51ZShlLGEsbyk7cmV0dXJuIHIuZ2VvbWV0cnk9ci5nZW9tZXRyeS5leHBvcnQoKSxzJiZkZWxldGUgci5zYW1wbGVJbmZvLHJ9YXN5bmMgcXVlcnkoZSxpLG4pe2lmKCFlKXRocm93IG5ldyB0KFwiZWxldmF0aW9uLXF1ZXJ5OmludmFsaWQtbGF5ZXJcIixcIkVsZXZhdGlvbiBxdWVyaWVzIHJlcXVpcmUgYW4gZWxldmF0aW9uIGxheWVyIHRvIGZldGNoIHRpbGVzIGZyb21cIik7aWYoIWl8fCEoaSBpbnN0YW5jZW9mIHcpJiZcInBvaW50XCIhPT1pLnR5cGUmJlwibXVsdGlwb2ludFwiIT09aS50eXBlJiZcInBvbHlsaW5lXCIhPT1pLnR5cGUpdGhyb3cgbmV3IHQoXCJlbGV2YXRpb24tcXVlcnk6aW52YWxpZC1nZW9tZXRyeVwiLFwiT25seSBwb2ludCwgcG9seWxpbmUgYW5kIG11bHRpcG9pbnQgZ2VvbWV0cmllcyBjYW4gYmUgdXNlZCB0byBxdWVyeSBlbGV2YXRpb25cIik7Y29uc3QgbD17Li4ucSwuLi5ufSxzPW5ldyBfKGUsaS5zcGF0aWFsUmVmZXJlbmNlLGwpLG89bC5zaWduYWw7cmV0dXJuIGF3YWl0IGUubG9hZCh7c2lnbmFsOm99KSxhd2FpdCB0aGlzLl9jcmVhdGVHZW9tZXRyeURlc2NyaXB0b3IocyxpLG8pLGF3YWl0IHRoaXMuX3NlbGVjdFRpbGVzKHMsbyksYXdhaXQgdGhpcy5fcG9wdWxhdGVFbGV2YXRpb25UaWxlcyhzLG8pLHRoaXMuX3NhbXBsZUdlb21ldHJ5V2l0aEVsZXZhdGlvbihzKSx0aGlzLl9jcmVhdGVRdWVyeVJlc3VsdChzLG8pfWFzeW5jIGNyZWF0ZVNhbXBsZXIoZSxpLG4pe2lmKCFlKXRocm93IG5ldyB0KFwiZWxldmF0aW9uLXF1ZXJ5OmludmFsaWQtbGF5ZXJcIixcIkVsZXZhdGlvbiBxdWVyaWVzIHJlcXVpcmUgYW4gZWxldmF0aW9uIGxheWVyIHRvIGZldGNoIHRpbGVzIGZyb21cIik7aWYoIWl8fFwiZXh0ZW50XCIhPT1pLnR5cGUpdGhyb3cgbmV3IHQoXCJlbGV2YXRpb24tcXVlcnk6aW52YWxpZC1leHRlbnRcIixcIkludmFsaWQgb3IgdW5kZWZpbmVkIGV4dGVudFwiKTtjb25zdCBsPXsuLi5xLC4uLm59O3JldHVybiB0aGlzLl9jcmVhdGVTYW1wbGVyKGUsaSxsKX1hc3luYyBjcmVhdGVTYW1wbGVyQWxsKGUsaSxuKXtpZighKGU9biYmbi5pZ25vcmVJbnZpc2libGVMYXllcnM/ZS5maWx0ZXIoKGU9PmUudmlzaWJsZSkpOmUuc2xpY2UoKSkubGVuZ3RoKXRocm93IG5ldyB0KFwiZWxldmF0aW9uLXF1ZXJ5OmludmFsaWQtbGF5ZXJcIixcIkVsZXZhdGlvbiBxdWVyaWVzIHJlcXVpcmUgYXQgbGVhc3Qgb25lIGVsZXZhdGlvbiBsYXllciB0byBmZXRjaCB0aWxlcyBmcm9tXCIpO2lmKCFpfHxcImV4dGVudFwiIT09aS50eXBlKXRocm93IG5ldyB0KFwiZWxldmF0aW9uLXF1ZXJ5OmludmFsaWQtZXh0ZW50XCIsXCJJbnZhbGlkIG9yIHVuZGVmaW5lZCBleHRlbnRcIik7Y29uc3QgbD17Li4ucSwuLi5uLHJldHVyblNhbXBsZUluZm86ITB9LHM9YXdhaXQgdGhpcy5fY3JlYXRlU2FtcGxlcihlW2UubGVuZ3RoLTFdLGksbCk7cmV0dXJuIHRoaXMuX2NyZWF0ZVNhbXBsZXJBbGxDb250aW51ZShlLGkscyxsKX1hc3luYyBfY3JlYXRlU2FtcGxlcihlLHQsaSxuKXtjb25zdCBsPWkuc2lnbmFsO2F3YWl0IGUubG9hZCh7c2lnbmFsOmx9KTtjb25zdCBzPXQuc3BhdGlhbFJlZmVyZW5jZSxvPWUudGlsZUluZm8uc3BhdGlhbFJlZmVyZW5jZTtzLmVxdWFscyhvKXx8KGF3YWl0IHUoW3tzb3VyY2U6cyxkZXN0Om99XSx7c2lnbmFsOmx9KSx0PWgodCxvKSk7Y29uc3QgYT1uZXcgRShlLHQsaSxuKTtyZXR1cm4gYXdhaXQgdGhpcy5fc2VsZWN0VGlsZXMoYSxsKSxhd2FpdCB0aGlzLl9wb3B1bGF0ZUVsZXZhdGlvblRpbGVzKGEsbCksbmV3IGQoYS5lbGV2YXRpb25UaWxlcyxhLmxheWVyLnRpbGVJbmZvLGEub3B0aW9ucy5ub0RhdGFWYWx1ZSl9YXN5bmMgX2NyZWF0ZVNhbXBsZXJBbGxDb250aW51ZShlLHQsaSxuKXtpZihlLnBvcCgpLCFlLmxlbmd0aClyZXR1cm4gaTtjb25zdCBsPWkuc2FtcGxlcnMubWFwKChlPT5wKGUuZXh0ZW50KSkpLHM9YXdhaXQgdGhpcy5fY3JlYXRlU2FtcGxlcihlW2UubGVuZ3RoLTFdLHQsbixsKTtpZigwPT09cy5zYW1wbGVycy5sZW5ndGgpcmV0dXJuIGk7Y29uc3Qgbz1pLnNhbXBsZXJzLmNvbmNhdChzLnNhbXBsZXJzKSxhPW5ldyBkKG8sbi5ub0RhdGFWYWx1ZSk7cmV0dXJuIHRoaXMuX2NyZWF0ZVNhbXBsZXJBbGxDb250aW51ZShlLHQsYSxuKX1hc3luYyBfcXVlcnlBbGxDb250aW51ZShlLHQsbil7Y29uc3QgbD1lLnBvcCgpLHM9dC5nZW9tZXRyeS5jb29yZGluYXRlcyxvPXQuc2FtcGxlSW5mbztpKG8pO2NvbnN0IGE9W10scj1bXTtmb3IobGV0IGk9MDtpPHMubGVuZ3RoO2krKyl7Y29uc3QgdD1vW2ldO3QuZGVtUmVzb2x1dGlvbj49MD90LnNvdXJjZXx8KHQuc291cmNlPWwpOmUubGVuZ3RoJiYoYS5wdXNoKHNbaV0pLHIucHVzaChpKSl9aWYoIWUubGVuZ3RofHwwPT09YS5sZW5ndGgpcmV0dXJuIHQ7Y29uc3QgYz10Lmdlb21ldHJ5LmNsb25lKGEpLHU9YXdhaXQgdGhpcy5xdWVyeShlW2UubGVuZ3RoLTFdLGMsbiksaD11LnNhbXBsZUluZm87aWYoIWgpdGhyb3cgbmV3IEVycm9yKFwibm8gc2FtcGxlSW5mb1wiKTtyZXR1cm4gci5mb3JFYWNoKCgoZSx0KT0+e3NbZV0uej11Lmdlb21ldHJ5LmNvb3JkaW5hdGVzW3RdLnosb1tlXS5kZW1SZXNvbHV0aW9uPWhbdF0uZGVtUmVzb2x1dGlvbn0pKSx0aGlzLl9xdWVyeUFsbENvbnRpbnVlKGUsdCxuKX1hc3luYyBfY3JlYXRlUXVlcnlSZXN1bHQoZSx0KXtjb25zdCBuPWF3YWl0IGUuZ2VvbWV0cnkucHJvamVjdChlLm91dFNwYXRpYWxSZWZlcmVuY2UsdCk7aShuKTtjb25zdCBsPXtnZW9tZXRyeTpuLmV4cG9ydCgpLG5vRGF0YVZhbHVlOmUub3B0aW9ucy5ub0RhdGFWYWx1ZX07cmV0dXJuIGUub3B0aW9ucy5yZXR1cm5TYW1wbGVJbmZvJiYobC5zYW1wbGVJbmZvPXRoaXMuX2V4dHJhY3RTYW1wbGVJbmZvKGUpKSxlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goKGU9PntlLnRpbGU9bnVsbCxlLmVsZXZhdGlvblRpbGU9bnVsbH0pKSxsfWFzeW5jIF9jcmVhdGVHZW9tZXRyeURlc2NyaXB0b3IoZSxpLG4pe2xldCBsO2NvbnN0IHM9ZS5sYXllci50aWxlSW5mby5zcGF0aWFsUmVmZXJlbmNlO2lmKGkgaW5zdGFuY2VvZiB3P2w9YXdhaXQgaS5wcm9qZWN0KHMsbik6KGF3YWl0IHUoW3tzb3VyY2U6aS5zcGF0aWFsUmVmZXJlbmNlLGRlc3Q6c31dLHtzaWduYWw6bn0pLGw9aChpLHMpKSwhbCl0aHJvdyBuZXcgdChcImVsZXZhdGlvbi1xdWVyeTpzcGF0aWFsLXJlZmVyZW5jZS1taXNtYXRjaFwiLGBDYW5ub3QgcXVlcnkgZWxldmF0aW9uIGluICcke2kuc3BhdGlhbFJlZmVyZW5jZS53a2lkfScgb24gYW4gZWxldmF0aW9uIHNlcnZpY2UgaW4gJyR7cy53a2lkfSdgKTtlLmdlb21ldHJ5PXcuZnJvbUdlb21ldHJ5KGwpfWFzeW5jIF9zZWxlY3RUaWxlcyhlLGkpe1wiZ2VvbWV0cnlcIj09PWUudHlwZSYmdGhpcy5fcHJlc2VsZWN0T3V0c2lkZUxheWVyRXh0ZW50KGUpO2NvbnN0IG49ZS5vcHRpb25zLmRlbVJlc29sdXRpb247aWYoXCJudW1iZXJcIj09dHlwZW9mIG4pdGhpcy5fc2VsZWN0VGlsZXNDbG9zZXN0UmVzb2x1dGlvbihlLG4pO2Vsc2UgaWYoXCJmaW5lc3QtY29udGlndW91c1wiPT09bilhd2FpdCB0aGlzLl9zZWxlY3RUaWxlc0ZpbmVzdENvbnRpZ3VvdXMoZSxpKTtlbHNle2lmKFwiYXV0b1wiIT09bil0aHJvdyBuZXcgdChcImVsZXZhdGlvbi1xdWVyeTppbnZhbGlkLWRlbS1yZXNvbHV0aW9uXCIsYEludmFsaWQgZGVtIHJlc29sdXRpb24gdmFsdWUgJyR7bn0nLCBleHBlY3RlZCBhIG51bWJlciwgXCJmaW5lc3QtY29udGlndW91c1wiIG9yIFwiYXV0b1wiYCk7YXdhaXQgdGhpcy5fc2VsZWN0VGlsZXNBdXRvKGUsaSl9fV9wcmVzZWxlY3RPdXRzaWRlTGF5ZXJFeHRlbnQoZSl7aWYobnVsbD09ZS5sYXllci5mdWxsRXh0ZW50KXJldHVybjtjb25zdCB0PW5ldyB5KG51bGwpO3Quc2FtcGxlPSgpPT5lLm9wdGlvbnMubm9EYXRhVmFsdWUsZS5vdXRzaWRlRXh0ZW50VGlsZT10O2NvbnN0IGk9ZS5sYXllci5mdWxsRXh0ZW50O2UuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCgoZT0+e2NvbnN0IG49ZS54LGw9ZS55OyhuPGkueG1pbnx8bj5pLnhtYXh8fGw8aS55bWlufHxsPmkueW1heCkmJihlLmVsZXZhdGlvblRpbGU9dCl9KSl9X3NlbGVjdFRpbGVzQ2xvc2VzdFJlc29sdXRpb24oZSx0KXtjb25zdCBpPXRoaXMuX2ZpbmROZWFyZXN0RGVtUmVzb2x1dGlvbkxPREluZGV4KGUsdCk7ZS5zZWxlY3RUaWxlc0F0TE9EKGkpfV9maW5kTmVhcmVzdERlbVJlc29sdXRpb25MT0RJbmRleChlLHQpe2NvbnN0e3RpbGVJbmZvOmksdGlsZW1hcENhY2hlOm59PWUubGF5ZXIsbD10L28oaS5zcGF0aWFsUmVmZXJlbmNlKSxzPUkoaSxuKTtsZXQgYT1zWzBdLHI9MDtmb3IobGV0IG89MTtvPHMubGVuZ3RoO28rKyl7Y29uc3QgZT1zW29dO01hdGguYWJzKGUucmVzb2x1dGlvbi1sKTxNYXRoLmFicyhhLnJlc29sdXRpb24tbCkmJihhPWUscj1vKX1yZXR1cm4gcn1hc3luYyBfc2VsZWN0VGlsZXNGaW5lc3RDb250aWd1b3VzKGUsdCl7Y29uc3R7dGlsZUluZm86aSx0aWxlbWFwQ2FjaGU6bn09ZS5sYXllcixsPVIoaSxuLGUub3B0aW9ucy5taW5EZW1SZXNvbHV0aW9uKTthd2FpdCB0aGlzLl9zZWxlY3RUaWxlc0ZpbmVzdENvbnRpZ3VvdXNBdChlLGwsdCl9YXN5bmMgX3NlbGVjdFRpbGVzRmluZXN0Q29udGlndW91c0F0KGUsaSxzKXtjb25zdCBvPWUubGF5ZXI7aWYoZS5zZWxlY3RUaWxlc0F0TE9EKGkpLGk8MClyZXR1cm47Y29uc3QgYT1vLnRpbGVtYXBDYWNoZSxyPWUuZ2V0VGlsZXNUb0ZldGNoKCk7dHJ5e2lmKGEmJiFBKGEpKWF3YWl0IG4oUHJvbWlzZS5hbGwoci5tYXAoKGU9PmEuZmV0Y2hBdmFpbGFiaWxpdHkoZS5sZXZlbCxlLnJvdyxlLmNvbCx7c2lnbmFsOnN9KSkpKSxzKTtlbHNlIGlmKGF3YWl0IHRoaXMuX3BvcHVsYXRlRWxldmF0aW9uVGlsZXMoZSxzKSwhZS5hbGxFbGV2YXRpb25UaWxlc0ZldGNoZWQoKSl0aHJvdyBlLmNsZWFyRWxldmF0aW9uVGlsZXMoKSxuZXcgdChcImVsZXZhdGlvbi1xdWVyeTpoYXMtdW5hdmFpbGFibGUtdGlsZXNcIil9Y2F0Y2goYyl7bChjKSxhd2FpdCB0aGlzLl9zZWxlY3RUaWxlc0ZpbmVzdENvbnRpZ3VvdXNBdChlLGktMSxzKX19YXN5bmMgX3BvcHVsYXRlRWxldmF0aW9uVGlsZXMoZSx0KXtjb25zdCBpPWUuZ2V0VGlsZXNUb0ZldGNoKCksbD17fSxvPWUub3B0aW9ucy5jYWNoZSxhPWUub3B0aW9ucy5ub0RhdGFWYWx1ZSxyPWkubWFwKChhc3luYyBpPT57aWYobnVsbD09aS5pZClyZXR1cm47Y29uc3Qgbj1gJHtlLmxheWVyLnVpZH06JHtpLmlkfToke2F9YCxzPW51bGwhPW8/by5nZXQobik6bnVsbCxyPW51bGwhPXM/czphd2FpdCBlLmxheWVyLmZldGNoVGlsZShpLmxldmVsLGkucm93LGkuY29sLHtub0RhdGFWYWx1ZTphLHNpZ25hbDp0fSk7bnVsbCE9byYmby5wdXQobixyKSxsW2kuaWRdPW5ldyB5KGkscil9KSk7YXdhaXQgbihzKHIpLHQpLGUucG9wdWxhdGVFbGV2YXRpb25UaWxlcyhsKX1hc3luYyBfc2VsZWN0VGlsZXNBdXRvKHQsaSl7dGhpcy5fc2VsZWN0VGlsZXNBdXRvRmluZXN0KHQpLHRoaXMuX3JlZHVjZVRpbGVzRm9yTWF4aW11bVJlcXVlc3RzKHQpO2NvbnN0IHM9dC5sYXllci50aWxlbWFwQ2FjaGU7aWYoIXN8fEEocykpcmV0dXJuIHRoaXMuX3NlbGVjdFRpbGVzQXV0b1ByZWZldGNoVXBzYW1wbGUodCxpKTtjb25zdCBvPXQuZ2V0VGlsZXNUb0ZldGNoKCksYT17fSxyPW8ubWFwKChhc3luYyB0PT57Y29uc3Qgbj1uZXcgVChudWxsLDAsMCwwLG0oKSksbz1hd2FpdCBlKHMuZmV0Y2hBdmFpbGFiaWxpdHlVcHNhbXBsZSh0LmxldmVsLHQucm93LHQuY29sLG4se3NpZ25hbDppfSkpOyExIT09by5vaz9udWxsIT10LmlkJiYoYVt0LmlkXT1uKTpsKG8uZXJyb3IpfSkpO2F3YWl0IG4oUHJvbWlzZS5hbGwociksaSksdC5yZW1hcFRpbGVzKGEpfV9yZWR1Y2VUaWxlc0Zvck1heGltdW1SZXF1ZXN0cyhlKXtjb25zdCB0PWUubGF5ZXIudGlsZUluZm87bGV0IGk9MDtjb25zdCBuPXt9LGw9ZT0+e251bGwhPWUuaWQmJihlLmlkIGluIG4/bltlLmlkXSsrOihuW2UuaWRdPTEsaSsrKSl9LHM9ZT0+e2lmKG51bGw9PWUuaWQpcmV0dXJuO2NvbnN0IHQ9bltlLmlkXTsxPT09dD8oZGVsZXRlIG5bZS5pZF0saS0tKTpuW2UuaWRdPXQtMX07ZS5mb3JFYWNoVGlsZVRvRmV0Y2gobCxzKTtsZXQgbz0hMDtmb3IoO28mJihvPSExLGUuZm9yRWFjaFRpbGVUb0ZldGNoKChuPT57aTw9ZS5vcHRpb25zLm1heGltdW1BdXRvVGlsZVJlcXVlc3RzfHwocyhuKSx0LnVwc2FtcGxlVGlsZShuKSYmKG89ITApLGwobikpfSkscyksbyk7KTt9X3NlbGVjdFRpbGVzQXV0b0ZpbmVzdChlKXtjb25zdHt0aWxlSW5mbzp0LHRpbGVtYXBDYWNoZTppfT1lLmxheWVyLG49Uih0LGksZS5vcHRpb25zLm1pbkRlbVJlc29sdXRpb24pO2Uuc2VsZWN0VGlsZXNBdExPRChuLGUub3B0aW9ucy5tYXhpbXVtQXV0b1RpbGVSZXF1ZXN0cyl9YXN5bmMgX3NlbGVjdFRpbGVzQXV0b1ByZWZldGNoVXBzYW1wbGUoZSx0KXtjb25zdCBpPWUubGF5ZXIudGlsZUluZm87YXdhaXQgdGhpcy5fcG9wdWxhdGVFbGV2YXRpb25UaWxlcyhlLHQpO2xldCBuPSExO2UuZm9yRWFjaFRpbGVUb0ZldGNoKCgoZSx0KT0+e2kudXBzYW1wbGVUaWxlKGUpP249ITA6dCgpfSkpLG4mJmF3YWl0IHRoaXMuX3NlbGVjdFRpbGVzQXV0b1ByZWZldGNoVXBzYW1wbGUoZSx0KX1fc2FtcGxlR2VvbWV0cnlXaXRoRWxldmF0aW9uKGUpe2UuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCgodD0+e2NvbnN0IGk9dC5lbGV2YXRpb25UaWxlO2xldCBuPWUub3B0aW9ucy5ub0RhdGFWYWx1ZTtpZihpKXtjb25zdCBlPWkuc2FtcGxlKHQueCx0LnkpO251bGwhPWU/bj1lOnQuZWxldmF0aW9uVGlsZT1udWxsfXQuej1ufSkpfV9leHRyYWN0U2FtcGxlSW5mbyhlKXtjb25zdCB0PWUubGF5ZXIudGlsZUluZm8saT1vKHQuc3BhdGlhbFJlZmVyZW5jZSk7cmV0dXJuIGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKChuPT57bGV0IGw9LTE7aWYobi5lbGV2YXRpb25UaWxlJiZuLmVsZXZhdGlvblRpbGUhPT1lLm91dHNpZGVFeHRlbnRUaWxlKXtsPXQubG9kQXQobi5lbGV2YXRpb25UaWxlLnRpbGUubGV2ZWwpLnJlc29sdXRpb24qaX1yZXR1cm57ZGVtUmVzb2x1dGlvbjpsfX0pKX19Y2xhc3Mgd3tleHBvcnQoKXtyZXR1cm4gdGhpcy5fZXhwb3J0ZXIodGhpcy5jb29yZGluYXRlcyx0aGlzLnNwYXRpYWxSZWZlcmVuY2UpfWNsb25lKGUpe2NvbnN0IHQ9bmV3IHc7cmV0dXJuIHQuZ2VvbWV0cnk9dGhpcy5nZW9tZXRyeSx0LnNwYXRpYWxSZWZlcmVuY2U9dGhpcy5zcGF0aWFsUmVmZXJlbmNlLHQuY29vcmRpbmF0ZXM9ZXx8dGhpcy5jb29yZGluYXRlcy5tYXAoKGU9PmUuY2xvbmUoKSkpLHQuX2V4cG9ydGVyPXRoaXMuX2V4cG9ydGVyLHR9YXN5bmMgcHJvamVjdChlLHQpe2lmKHRoaXMuc3BhdGlhbFJlZmVyZW5jZS5lcXVhbHMoZSkpcmV0dXJuIHRoaXMuY2xvbmUoKTthd2FpdCB1KFt7c291cmNlOnRoaXMuc3BhdGlhbFJlZmVyZW5jZSxkZXN0OmV9XSx7c2lnbmFsOnR9KTtjb25zdCBpPW5ldyBhKHtzcGF0aWFsUmVmZXJlbmNlOnRoaXMuc3BhdGlhbFJlZmVyZW5jZSxwb2ludHM6dGhpcy5jb29yZGluYXRlcy5tYXAoKGU9PltlLngsZS55XSkpfSksbj1oKGksZSk7aWYoIW4pcmV0dXJuIG51bGw7Y29uc3QgbD10aGlzLmNvb3JkaW5hdGVzLm1hcCgoKGUsdCk9Pntjb25zdCBpPWUuY2xvbmUoKSxsPW4ucG9pbnRzW3RdO3JldHVybiBpLng9bFswXSxpLnk9bFsxXSxpfSkpLHM9dGhpcy5jbG9uZShsKTtyZXR1cm4gcy5zcGF0aWFsUmVmZXJlbmNlPWUsc31zdGF0aWMgZnJvbUdlb21ldHJ5KGUpe2NvbnN0IHQ9bmV3IHc7aWYodC5nZW9tZXRyeT1lLHQuc3BhdGlhbFJlZmVyZW5jZT1lLnNwYXRpYWxSZWZlcmVuY2UsZSBpbnN0YW5jZW9mIHcpdC5jb29yZGluYXRlcz1lLmNvb3JkaW5hdGVzLm1hcCgoZT0+ZS5jbG9uZSgpKSksdC5fZXhwb3J0ZXI9KHQsaSk9Pntjb25zdCBuPWUuY2xvbmUodCk7cmV0dXJuIG4uc3BhdGlhbFJlZmVyZW5jZT1pLG59O2Vsc2Ugc3dpdGNoKGUudHlwZSl7Y2FzZVwicG9pbnRcIjp7Y29uc3QgaT1lLHtoYXNaOm4saGFzTTpsfT1pO3QuY29vcmRpbmF0ZXM9biYmbD9bbmV3IGcoaS54LGkueSxpLnosaS5tKV06bj9bbmV3IGcoaS54LGkueSxpLnopXTpsP1tuZXcgZyhpLngsaS55LG51bGwsaS5tKV06W25ldyBnKGkueCxpLnkpXSx0Ll9leHBvcnRlcj0odCxpKT0+ZS5oYXNNP25ldyByKHRbMF0ueCx0WzBdLnksdFswXS56LHRbMF0ubSxpKTpuZXcgcih0WzBdLngsdFswXS55LHRbMF0ueixpKTticmVha31jYXNlXCJtdWx0aXBvaW50XCI6e2NvbnN0IGk9ZSx7aGFzWjpuLGhhc006bH09aTt0LmNvb3JkaW5hdGVzPW4mJmw/aS5wb2ludHMubWFwKChlPT5uZXcgZyhlWzBdLGVbMV0sZVsyXSxlWzNdKSkpOm4/aS5wb2ludHMubWFwKChlPT5uZXcgZyhlWzBdLGVbMV0sZVsyXSkpKTpsP2kucG9pbnRzLm1hcCgoZT0+bmV3IGcoZVswXSxlWzFdLG51bGwsZVsyXSkpKTppLnBvaW50cy5tYXAoKGU9Pm5ldyBnKGVbMF0sZVsxXSkpKSx0Ll9leHBvcnRlcj0odCxpKT0+ZS5oYXNNP25ldyBhKHtwb2ludHM6dC5tYXAoKGU9PltlLngsZS55LGUueixlLm1dKSksaGFzWjohMCxoYXNNOiEwLHNwYXRpYVJlZmVyZW5jZTppfSk6bmV3IGEodC5tYXAoKGU9PltlLngsZS55LGUuel0pKSxpKTticmVha31jYXNlXCJwb2x5bGluZVwiOntjb25zdCBpPWUsbj1bXSxsPVtdLHtoYXNaOnMsaGFzTTpvfT1lO2xldCBhPTA7Zm9yKGNvbnN0IGUgb2YgaS5wYXRocylpZihsLnB1c2goW2EsYStlLmxlbmd0aF0pLGErPWUubGVuZ3RoLHMmJm8pZm9yKGNvbnN0IHQgb2YgZSluLnB1c2gobmV3IGcodFswXSx0WzFdLHRbMl0sdFszXSkpO2Vsc2UgaWYocylmb3IoY29uc3QgdCBvZiBlKW4ucHVzaChuZXcgZyh0WzBdLHRbMV0sdFsyXSkpO2Vsc2UgaWYobylmb3IoY29uc3QgdCBvZiBlKW4ucHVzaChuZXcgZyh0WzBdLHRbMV0sbnVsbCx0WzJdKSk7ZWxzZSBmb3IoY29uc3QgdCBvZiBlKW4ucHVzaChuZXcgZyh0WzBdLHRbMV0pKTt0LmNvb3JkaW5hdGVzPW4sdC5fZXhwb3J0ZXI9KHQsaSk9Pntjb25zdCBuPWUuaGFzTT90Lm1hcCgoZT0+W2UueCxlLnksZS56LGUubV0pKTp0Lm1hcCgoZT0+W2UueCxlLnksZS56XSkpLHM9bC5tYXAoKGU9Pm4uc2xpY2UoZVswXSxlWzFdKSkpO3JldHVybiBuZXcgYyh7cGF0aHM6cyxoYXNNOmUuaGFzTSxoYXNaOiEwLHNwYXRpYWxSZWZlcmVuY2U6aX0pfTticmVha319cmV0dXJuIHR9fWNsYXNzIGd7Y29uc3RydWN0b3IoZSx0LGk9bnVsbCxuPW51bGwsbD1udWxsLHM9bnVsbCl7dGhpcy54PWUsdGhpcy55PXQsdGhpcy56PWksdGhpcy5tPW4sdGhpcy50aWxlPWwsdGhpcy5lbGV2YXRpb25UaWxlPXN9Y2xvbmUoKXtyZXR1cm4gbmV3IGcodGhpcy54LHRoaXMueSx0aGlzLnosdGhpcy5tKX19Y2xhc3MgeHtjb25zdHJ1Y3RvcihlLHQpe3RoaXMubGF5ZXI9ZSx0aGlzLm9wdGlvbnM9dH19Y2xhc3MgXyBleHRlbmRzIHh7Y29uc3RydWN0b3IoZSx0LGkpe3N1cGVyKGUsaSksdGhpcy5vdXRTcGF0aWFsUmVmZXJlbmNlPXQsdGhpcy50eXBlPVwiZ2VvbWV0cnlcIn1zZWxlY3RUaWxlc0F0TE9EKGUpe2lmKGU8MCl0aGlzLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goKGU9PmUudGlsZT1udWxsKSk7ZWxzZXtjb25zdHt0aWxlSW5mbzp0LHRpbGVtYXBDYWNoZTppfT10aGlzLmxheWVyLG49SSh0LGkpW2VdLmxldmVsO3RoaXMuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCgoZT0+ZS50aWxlPXQudGlsZUF0KG4sZS54LGUueSkpKX19YWxsRWxldmF0aW9uVGlsZXNGZXRjaGVkKCl7cmV0dXJuIXRoaXMuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuc29tZSgoZT0+IWUuZWxldmF0aW9uVGlsZSkpfWNsZWFyRWxldmF0aW9uVGlsZXMoKXtmb3IoY29uc3QgZSBvZiB0aGlzLmdlb21ldHJ5LmNvb3JkaW5hdGVzKWUuZWxldmF0aW9uVGlsZSE9PXRoaXMub3V0c2lkZUV4dGVudFRpbGUmJihlLmVsZXZhdGlvblRpbGU9bnVsbCl9cG9wdWxhdGVFbGV2YXRpb25UaWxlcyhlKXtmb3IoY29uc3QgdCBvZiB0aGlzLmdlb21ldHJ5LmNvb3JkaW5hdGVzKSF0LmVsZXZhdGlvblRpbGUmJnQudGlsZT8uaWQmJih0LmVsZXZhdGlvblRpbGU9ZVt0LnRpbGUuaWRdKX1yZW1hcFRpbGVzKGUpe2Zvcihjb25zdCB0IG9mIHRoaXMuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpe2NvbnN0IGk9dC50aWxlPy5pZDt0LnRpbGU9aT9lW2ldOm51bGx9fWdldFRpbGVzVG9GZXRjaCgpe2NvbnN0IGU9e30sdD1bXTtmb3IoY29uc3QgaSBvZiB0aGlzLmdlb21ldHJ5LmNvb3JkaW5hdGVzKXtjb25zdCBuPWkudGlsZTtpZighbiljb250aW51ZTtjb25zdCBsPWkudGlsZT8uaWQ7aS5lbGV2YXRpb25UaWxlfHwhbHx8ZVtsXXx8KGVbbF09bix0LnB1c2gobikpfXJldHVybiB0fWZvckVhY2hUaWxlVG9GZXRjaChlKXtmb3IoY29uc3QgdCBvZiB0aGlzLmdlb21ldHJ5LmNvb3JkaW5hdGVzKXQudGlsZSYmIXQuZWxldmF0aW9uVGlsZSYmZSh0LnRpbGUsKCgpPT57dC50aWxlPW51bGx9KSl9fWNsYXNzIEUgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKGUsdCxpLG4pe3N1cGVyKGUsaSksdGhpcy50eXBlPVwiZXh0ZW50XCIsdGhpcy5lbGV2YXRpb25UaWxlcz1bXSx0aGlzLl9jYW5kaWRhdGVUaWxlcz1bXSx0aGlzLl9mZXRjaGVkQ2FuZGlkYXRlcz1uZXcgU2V0LHRoaXMuZXh0ZW50PXQuaW50ZXJzZWN0aW9uKGUuZnVsbEV4dGVudCksdGhpcy5tYXNrRXh0ZW50cz1ufXNlbGVjdFRpbGVzQXRMT0QoZSx0KXtjb25zdCBpPXRoaXMuX21heGltdW1Mb2RGb3JSZXF1ZXN0cyh0KSxuPU1hdGgubWluKGksZSk7bjwwP3RoaXMuX2NhbmRpZGF0ZVRpbGVzLmxlbmd0aD0wOnRoaXMuX3NlbGVjdENhbmRpZGF0ZVRpbGVzQ292ZXJpbmdFeHRlbnRBdChuKX1fbWF4aW11bUxvZEZvclJlcXVlc3RzKGUpe2NvbnN0e3RpbGVJbmZvOnQsdGlsZW1hcENhY2hlOml9PXRoaXMubGF5ZXIsbj1JKHQsaSk7aWYoIWUpcmV0dXJuIG4ubGVuZ3RoLTE7Y29uc3QgbD10aGlzLmV4dGVudDtpZihudWxsPT1sKXJldHVybi0xO2ZvcihsZXQgcz1uLmxlbmd0aC0xO3M+PTA7cy0tKXtjb25zdCBpPW5bc10sbz1pLnJlc29sdXRpb24qdC5zaXplWzBdLGE9aS5yZXNvbHV0aW9uKnQuc2l6ZVsxXTtpZihNYXRoLmNlaWwobC53aWR0aC9vKSpNYXRoLmNlaWwobC5oZWlnaHQvYSk8PWUpcmV0dXJuIHN9cmV0dXJuLTF9YWxsRWxldmF0aW9uVGlsZXNGZXRjaGVkKCl7cmV0dXJuIHRoaXMuX2NhbmRpZGF0ZVRpbGVzLmxlbmd0aD09PXRoaXMuZWxldmF0aW9uVGlsZXMubGVuZ3RofWNsZWFyRWxldmF0aW9uVGlsZXMoKXt0aGlzLmVsZXZhdGlvblRpbGVzLmxlbmd0aD0wLHRoaXMuX2ZldGNoZWRDYW5kaWRhdGVzLmNsZWFyKCl9cG9wdWxhdGVFbGV2YXRpb25UaWxlcyhlKXtmb3IoY29uc3QgdCBvZiB0aGlzLl9jYW5kaWRhdGVUaWxlcyl7Y29uc3QgaT10LmlkJiZlW3QuaWRdO2kmJih0aGlzLl9mZXRjaGVkQ2FuZGlkYXRlcy5hZGQodCksdGhpcy5lbGV2YXRpb25UaWxlcy5wdXNoKGkpKX19cmVtYXBUaWxlcyhlKXt0aGlzLl9jYW5kaWRhdGVUaWxlcz10aGlzLl91bmlxdWVOb25PdmVybGFwcGluZ1RpbGVzKHRoaXMuX2NhbmRpZGF0ZVRpbGVzLm1hcCgodD0+ZVt0LmlkXSkpKX1nZXRUaWxlc1RvRmV0Y2goKXtyZXR1cm4gdGhpcy5fY2FuZGlkYXRlVGlsZXN9Zm9yRWFjaFRpbGVUb0ZldGNoKGUsdCl7Y29uc3QgaT10aGlzLl9jYW5kaWRhdGVUaWxlczt0aGlzLl9jYW5kaWRhdGVUaWxlcz1bXSxpLmZvckVhY2goKGk9PntpZih0aGlzLl9mZXRjaGVkQ2FuZGlkYXRlcy5oYXMoaSkpcmV0dXJuIHZvaWQodCYmdChpKSk7bGV0IG49ITE7ZShpLCgoKT0+bj0hMCkpLG4/dCYmdChpKTp0aGlzLl9jYW5kaWRhdGVUaWxlcy5wdXNoKGkpfSkpLHRoaXMuX2NhbmRpZGF0ZVRpbGVzPXRoaXMuX3VuaXF1ZU5vbk92ZXJsYXBwaW5nVGlsZXModGhpcy5fY2FuZGlkYXRlVGlsZXMsdCl9X3VuaXF1ZU5vbk92ZXJsYXBwaW5nVGlsZXMoZSx0KXtjb25zdCBpPXt9LG49W107Zm9yKGNvbnN0IHMgb2YgZSl7Y29uc3QgZT1zLmlkO2UmJiFpW2VdPyhpW2VdPXMsbi5wdXNoKHMpKTp0JiZ0KHMpfWNvbnN0IGw9bi5zb3J0KCgoZSx0KT0+ZS5sZXZlbC10LmxldmVsKSk7cmV0dXJuIGwuZmlsdGVyKCgoZSxpKT0+e2ZvcihsZXQgbj0wO248aTtuKyspe2NvbnN0IGk9bFtuXS5leHRlbnQ7aWYoaSYmZS5leHRlbnQmJmYoaSxlLmV4dGVudCkpcmV0dXJuIHQmJnQoZSksITF9cmV0dXJuITB9KSl9X3NlbGVjdENhbmRpZGF0ZVRpbGVzQ292ZXJpbmdFeHRlbnRBdChlKXt0aGlzLl9jYW5kaWRhdGVUaWxlcy5sZW5ndGg9MDtjb25zdCB0PXRoaXMuZXh0ZW50O2lmKG51bGw9PXQpcmV0dXJuO2NvbnN0e3RpbGVJbmZvOmksdGlsZW1hcENhY2hlOm59PXRoaXMubGF5ZXIsbD1JKGksbilbZV0scz1pLnRpbGVBdChsLmxldmVsLHQueG1pbix0LnltaW4pLG89cy5leHRlbnQ7aWYobnVsbD09bylyZXR1cm47Y29uc3QgYT1sLnJlc29sdXRpb24qaS5zaXplWzBdLHI9bC5yZXNvbHV0aW9uKmkuc2l6ZVsxXSxjPU1hdGguY2VpbCgodC54bWF4LW9bMF0pL2EpLHU9TWF0aC5jZWlsKCh0LnltYXgtb1sxXSkvcik7Zm9yKGxldCBoPTA7aDx1O2grKylmb3IobGV0IGU9MDtlPGM7ZSsrKXtjb25zdCB0PW5ldyBUKG51bGwscy5sZXZlbCxzLnJvdy1oLHMuY29sK2UpO2kudXBkYXRlVGlsZUluZm8odCksdGhpcy5fdGlsZUlzTWFza2VkKHQpfHx0aGlzLl9jYW5kaWRhdGVUaWxlcy5wdXNoKHQpfX1fdGlsZUlzTWFza2VkKGUpe3JldHVybiEhdGhpcy5tYXNrRXh0ZW50cyYmdGhpcy5tYXNrRXh0ZW50cy5zb21lKCh0PT5lLmV4dGVudCYmZih0LGUuZXh0ZW50KSkpfX1mdW5jdGlvbiBSKGUsdCxpPTApe2NvbnN0IG49SShlLHQpO2xldCBsPW4ubGVuZ3RoLTE7aWYoaT4wKXtjb25zdCB0PWkvbyhlLnNwYXRpYWxSZWZlcmVuY2UpLHM9bi5maW5kSW5kZXgoKGU9PmUucmVzb2x1dGlvbjx0KSk7MD09PXM/bD0wOnM+MCYmKGw9cy0xKX1yZXR1cm4gbH1jb25zdCBxPXttYXhpbXVtQXV0b1RpbGVSZXF1ZXN0czoyMCxub0RhdGFWYWx1ZTowLHJldHVyblNhbXBsZUluZm86ITEsZGVtUmVzb2x1dGlvbjpcImF1dG9cIixtaW5EZW1SZXNvbHV0aW9uOjB9O2Z1bmN0aW9uIEkoZSx0KXtjb25zdCBpPWUubG9kcztpZihBKHQpKXtjb25zdHtlZmZlY3RpdmVNaW5MT0Q6ZSxlZmZlY3RpdmVNYXhMT0Q6bn09dDtyZXR1cm4gaS5maWx0ZXIoKHQ9PnQubGV2ZWw+PWUmJnQubGV2ZWw8PW4pKX1yZXR1cm4gaX1mdW5jdGlvbiBBKGUpe3JldHVybiBudWxsIT1lPy50aWxlSW5mb31leHBvcnR7diBhcyBFbGV2YXRpb25RdWVyeSx3IGFzIEdlb21ldHJ5RGVzY3JpcHRvcixSIGFzIGdldEZpbmVzdExvZEluZGV4fTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22420\n");

/***/ })

}]);